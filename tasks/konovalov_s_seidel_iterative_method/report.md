# <Подсчет буквенных символов в строке>

- Student: <Коновалов Сергей Александрович>, group <3823Б1Пр3>
- Technology: <SEQ | MPI>
- Variant: <19>

## 1. Introduction
Задача решения итеративным методом Зейделя систем линейных алгебраических уравнений вида Ax=b, где 
- A - матрица коэффициентов при неизвестных
- b - вектор свободных членов
- x - вектор неизвестных

Суть метода можно описать так: из каждого уравнения выражается неизвестное, соответствующее коэффициенту на диагонали матрицы A, выбираются начальные приближения неизвестных для нулевого цикла (как правило, каждая неизвестная = 0) и выполняется нулевой цикл.
На нулевом цикле используются начальные приближения для вычисления новых значений неизвестных, при этом новые значения, полученные на предыдущих итерациях каждого цикла, используются в последующих вычисления оставшихся неизвестных. 
Новые значения неизвестных, полученные в результате работы алгоритма, сохраняются и используются как начальные приближения в следующем цикле. 
Алгоритм заканчивает работу в двух случаях:
- Положительный - необходимой точности вычислений удалось достичь за количество итераций меньше максимального
- Негативный - достигнуто максимальное количество итераций, т.е. требуемая точность не достигнута

Известно, что метод зейделя обладает наилучшей сходимостью (она обеспечивается диагонально-доминантными матрицами коэффициентов, так что отношение любых других коэффициентов к диагональному в одной строке меньше единицы), вплоть до точного результата.

Метод зейделя широко используется для описания взаимодействия плотных объектов в 3D моделировании.

## 2. Problem Statement
Одной из главных проблем стало представление тестовых данных.
Изначально предполагалось использование внешних источников, в которых некоторым образом были бы записаны матрицы A и b, размер матрицы и максимальное количество итераций, а так же верный ответ. Тем самым алгоритм можно было бы испытывать на реальных системах.
Однако, начав реализовывать параллельную версию, от этой идеи пришлось отказаться и перейти к генерации данных.

К генерации данных, в свою очередь, вынудило перейти изучение вопроса о параллелизации метода Гаусса-Зейделя. 
Из изученного материала я выяснил, что принцип его параллелизации лежит в нахождении независимых неизвестных - тех, что не учавствуют в уравнениях друг друга, т.е. чьи симметричные коэффициенты равны 0 (пр.: х1,3 = х3,1 = 0). 
Подобных переменных в системе может быть как несколько (пр.: 2 блока попарно независимых неизвесных при размере вектора 4), так и не быть вовсе. За определение подобных неизвестных отвечает алгоритм закраски графа (забегая вперед, матрица коэффициентов представлена в виде одномерного вектора): 

```
std::vector<int> A = _A;       // coefficient matrix.int
  std::vector<int> color(size);  // colors of rows.
  for (int i = 0; i < size; ++i) {
    color[i] = -1;
  }
  for (int i = 0; i < size; ++i) {
    int m = 0;
    for (int j = 0; j < i; j++) {
      if (A[i * size + j] != 0 && color[j] == m) {
        ++m;
      }
    }
    color[i] = m;
  }
```

Его работу можно описать так: проходя по матрице коэффициентов, алгоритм считает ненулевые элементы в рядах матрицы, возвращая полученные значения для каждого ряда. Индексы с одинаковыми значениями принадлежат одному блоку независимых неизвестных, следовательно могут быть посчитаны в любом порядке, и как итог, их вычисление можно вынести на разные процессы для одновременного подсчета. Единственное, остается зависимость в подсчете блоков (первым должен быть посчитан блок содержащий уравнение х0, затем блок содержащий х1 и т.д.), однако достаточно легко решается нумерацией блоков.

Сам алгоритм закраски графа в итоговой версии не используется, но он привел к итоговому решению.


## 3. Baseline Algorithm (Sequential)
Последовательный алгоритм:
- Считывает входные данные
- Генерирует матрицы методами InitMatrixA() и InitMatrixB() соотретственно, основываясь на количестве неизвестных (в GetInput())
- Выполняет функцию Iterativeprocess()
- Полученный результат передает GetOutput()

Алгоритм содержится в Iterativeprocess() в своей самой рапространенной реализации.

Алгоритм генерации данных в большей степени заточен на MPI реализацию, поэтому параллельная версия генерирует несколько другие матрицы, что не критично для тестов функционала.

srand(time(NULL)) используется для обновления счетчика рандомайзера для получения случайных результатов каждый раз при запуске генераций.

## 4. Parallelization Scheme
Идея распараллеливания вычислений заключается в следующем:
Разделение обязанностей:
### 1. Процесс-дистрибьютор
- Один из процессов (ранг 0) выступает в роли дистрибьютора данных.
- Он считывает водные данные, генерирует матрицы на их основе, а также в зависимости от запущенных процессов таким образом, что каждый процесс будет высчитывать одинаковое количество блоков независимых неизвестных, поровну разделяя нагрузку.
- - Этот процесс единственный, кто имеет полную матрицы коэффициентов и свободных членов (только в функции DataDistr()).
- Процесс делит полученные матрицы между процессами-получателями и отправляет их.
- - Передача осуществляется логикой Send-Recv в том числе для синхронизации действий потоков.
- После того, как строки были отправлены, процесс попадает в общий цикл и встает в состояние ожидания пока другие процессы не закончат шаг итерации Зейделя.
- Затем процесс собирает новые значения локальных векторов неизвестных, объединяет их в глобальный вектор новых значений неизвестных gl_x_vec, передавая это новое значение остальным процессам через Bcast.
### 2. Процесс-получатель
- Каждый процесс находится в состоянии ожидания входящих сообщений и инициализирует массив локальной матрицы коэффициентов размером по размеру из GetInput(), а также по известному ему количеству процессов, равному количеству блоков независимых неизвестных, и следовательно, количеству высчитываемых процессом уравнений, аналогично с матрицей свободных членов.
- - Передача осуществляется логикой Send-Recv в том числе для синхронизации действий потоков.
- С полученными данными процесс начинает вычисление шагов метода Зейделя.
- - Функция, реализующая алгоритм была модифицирована под взаимодействие с процессом, добавлены переменные с адресами диагональных коэффициентов, изменен способ обращения к массиву и главное - была убрана цикличность до достижения точности.
- Вычислив новые значения своих неизвестных, процесс сравнивает новые значения со старыми, хранящимися в gl_x_vec.
- - Используется логическое И на предмет наличия неизвестного, всё ещё не достигшего необходимой точности на каждом процессе, результат сохраняется в переменной cover_tracker.
- В конце общего цикла процессы обмениваются локальными данными о неизвестных, получая взамен новые данные gl_x_vec
### 3. Общая часть
- Закончив обмен начальными данными все процессы попадают в общий цикл, имитирующий итерации метода Зейделя.
- - Каждый процесс имеет свой итератор цикла, а так же флаг выхода из общего цикла.
- - В конце каждой итерации итератор уменьшается на 1 и делается проверка флага:
- - - Используется функция Allreduce по переменной cover_tracker с использованием аргумента MPI_LAND: пока есть хоть один процесс, возвращающий при запросе false, то точность не достигнута, цикл продолжается (Нулевой процесс всегда возвращает true, поэтому он не влияет на результат умножения).
- При завершении общего цикла, процессы передают данные gl_x_vec в GetOutput()

## 5. Implementation Details
Тестовые данные хранятся в папке /data с ключевым словом "text_line_[correct_ans]". Файл открывается и обрабатывается в классе теста.
Ввиду своей простоты, весь алгоритм реализован в методе RunImpl().

## 6. Experimental Setup
Проект запускался в WSL с помощью докера.
- CPU: Intel Xeon CPU E5-2678 v3 2.50GHz
- Cores: 12
- RAM: 7.5 Gb
- OS: Ubuntu 24.04.3 LTS 
- Compiler: GCC
- Build type: Release
- Environment: PPC_NUM_PROC
- Data: tasks/konovalov_s_symbol_count/data

## 7. Results and Discussion

### 7.1 Correctness
Функциональный тест сверяет выходные данные на предмет адекватности - вероятность того, что случайно сгенерированная система имеет решение в виде вектора нулей маловероятно. Для параллельной версии, проверяются результаты каждого процесса. 
Алгоритм справился с фунциональными тестами, как на последовательной, так и на параллельной версии.

### 7.2 Performance
Present time, speedup and efficiency. Example table:

| Mode        | Count | Time, s | Speedup | Efficiency |
|-------------|-------|---------|---------|------------|
| seq         | 1     | 1.234   | 1.00    | N/A        |
| mpi         | 2     | 0.700   | 1.76    | 88.0%      |
| omp         | 4     | 0.390   | 3.16    | 79.0%      |



## 9. References
1. <(https://www.opennet.ru/)>
2. <https://erkaman.github.io/posts/gauss_seidel_graph_coloring.html>
3. <https://zumbs.wordpress.com/wp-content/uploads/2010/09/a-parallel-gauss-seidel-method-for-computing-contact-forces.pdf>

## Appendix (Optional)
```cpp
// Short, readable code excerpts if needed
```