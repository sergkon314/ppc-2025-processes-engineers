# <Подсчет буквенных символов в строке>

- Student: <Коновалов Сергей Александрович>, group <3823Б1Пр3>
- Technology: <SEQ | MPI>
- Variant: <22>

## 1. Introduction
Вводная задача на реализацию простого алгоритма чтения строки. Строка константна, загружается из внешнего источника. Алгоритм должен вернуть количество буквенных символов в строке.

## 2. Problem Statement
Главной задачей является посчет буквенных символов в строке. 

'''InType = std::string'''
В качестве входных данных в программу передается строка, в которой содержится заранее известное число буквенных символов. Для работы алгоритма не требуются какие-либо дополнительные входные данные.

'''OutType = std::tuple<int, int>'''
В качестве выходных данных программа возвращает посчитанное число буквенных символов в строке, а также номер процесса-отправителя для валидации данных (последовательная версия по умолчанию передает ранг процесса 0).

## 3. Baseline Algorithm (Sequential)
Последовательный алгоритм выполняет следующие действия:
- Считывает строку из входных данных.
- Вычисляет количество искомых символов с помощью функции count_if(), определяя тип символов функцией isdigit().
- Формирует возвращаемое значение GetOutput() с помощью функции make_tuple().

count_if() - возвращает количество элементов в массиве, удовлетвояющие заданному устовию.
isdigit() - возвращает одно из булевых значений: 1 - элмент является числом, 0 - элмент не является числом.
make_tuple() - возвращает данные типа std::tuple<>.

## 4. Parallelization Scheme
Идея распараллеливания вычислений заключается в следующем:
Разделение обязанностей:
### 1. Процесс-дистрибьютор
- Один из процессов (ранг 0) выступает в роли дистрибьютора данных, разделяя исходную строку на равные части.
- Процесс передаёт полученные подстроки процессам-получателям.
- - Так как строка может не поделиться поровну, последнему процессу-получателю будут переданы остаточные символы исходной строки.
- После того, как строки были отправлены, процесс встает в состояние ожидания ответа от процессов - число буквенных символов в их подстроках.
- - При получении результата, процесс прибавляет полученное значение к переменной mpi_non_digit_count, хранящей общее число буквенных символов в исходной строке, т.е. ответ.
- Получив все ответы, процесс формирует возвращаемое значение GetOutput() и заканчивает выполнение метода.
### 2. Процесс-получатель
- Каждый процесс находится в состоянии ожидания входящих сообщений и инициализирует массив размером по длине сообщения.
- - После получения сообщения процесс вычисляет количество искомых символов с помощью функции count_if(), определяя тип символов функцией isdigit().
- После подсчета, процесс посылает результат процессу-дистрибьютору.
### 3. Общая часть
- Все процессы подсчитывают промежуточные значения count методом Allreduce и записывают итоговый резутьтат в gl_non_digit_count.
- Процессы выходят из алгоритма и завершают работу.

## 5. Implementation Details
Тестовые данные хранятся в папке /data с ключевым словом "text_line_[correct_ans]". Файл открывается и обрабатывается в классе теста.
Ввиду своей простоты, весь алгоритм реализован в методе RunImpl().

## 6. Experimental Setup
Проект запускался в WSL с помощью докера.
- CPU: Intel Xeon CPU E5-2678 v3 2.50GHz
- Cores: 12
- RAM: 7.5 Gb
- OS: Ubuntu 24.04.3 LTS 
- Compiler: GCC
- Build type: Release
- Environment: PPC_NUM_PROC
- Data: tasks/konovalov_s_symbol_count/data

## 7. Results and Discussion

### 7.1 Correctness
Функциональный тест сверяет заранее известный верный ответ для данной строки символов с результатом, полученным в результате выполнения алгоритма. Для параллельной версии, верный ответ сверяется с результатами каждого процесса. 
Алгоритм справился с фунциональными тестами, как на последовательной, так и на параллельной версии.

### 7.2 Performance
Present time, speedup and efficiency. Example table:

| Mode        | Count | Time, s | Speedup | Efficiency |
|-------------|-------|---------|---------|------------|
| seq         | 1     | 1.234   | 1.00    | N/A        |
| mpi         | 2     | 0.700   | 1.76    | 88.0%      |
| omp         | 4     | 0.390   | 3.16    | 79.0%      |



## 9. References
1. <Article/Book/Doc [URL](https://www.opennet.ru/)>
2. <Another source>

## Appendix (Optional)
```cpp
// Short, readable code excerpts if needed
```
